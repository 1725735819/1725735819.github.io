<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://1725735819.github.io</id>
    <title>Gridea</title>
    <updated>2021-04-27T04:06:16.698Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://1725735819.github.io"/>
    <link rel="self" href="https://1725735819.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://1725735819.github.io/images/avatar.png</logo>
    <icon>https://1725735819.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot系列之IDEA2020.2.1破解]]></title>
        <id>https://1725735819.github.io/post/springboot-xi-lie-zhi-idea202021-po-jie/</id>
        <link href="https://1725735819.github.io/post/springboot-xi-lie-zhi-idea202021-po-jie/">
        </link>
        <updated>2020-10-02T00:58:57.000Z</updated>
        <content type="html"><![CDATA[<p>破解成功可激活到2089<br>
注意事项：<br>
1、不需要重新下载应用；<br>
2、本激活方法适用于2020、2019、2018全系列版本；<br>
3、如果软件目前已过试用期且无法输入激活码（即激活码框不能输入），请卸载软件重新安装后再激活；</p>
<p>第一步: 下载最新的 IDEA 2020.2.1 版本安装包</p>
<p>我们先从 IDEA 官网下载 IDEA 2020.2.1 版本的安装包，下载链接如下：<br>
https://www.jetbrains.com/idea/download/<br>
<img src="https://1725735819.github.io/post-images/1601600534674.jpg" alt="" loading="lazy"></p>
<p>第二步: 先卸载老版本的 IDEA<br>
注意，如果电脑上之前有安装老版本的 IDEA, 需要先卸载干净，否则可能安装失败！</p>
<p>注意，一定要先卸载干净掉老版本的 IDEA。<img src="https://1725735819.github.io/post-images/1601600648630.jpg" alt="" loading="lazy"></p>
<p>卸载成功后，点击关闭<br>
<img src="https://1725735819.github.io/post-images/1601600755491.jpg" alt="" loading="lazy"></p>
<p>卸载成功后，双击刚刚下载好的 idea exe 格式安装包, 打开它；<br>
第三步: 开始激活 IDEA 2020.2.1 版本<br>
2.安装目录默认为 C:\Program Files\JetBrains\IntelliJ IDEA 2020.2.1, 这里笔者选择的是默认路径:<br>
<img src="https://1725735819.github.io/post-images/1601600854129.jpg" alt="" loading="lazy"><br>
3.勾选自己想要创建的桌面快捷方式，笔者的操作系统是 64 位的，所以勾选的 64 位快捷方式：<br>
<img src="https://1725735819.github.io/post-images/1601600918665.jpg" alt="" loading="lazy"><br>
4.点击 Install：<br>
<img src="https://1725735819.github.io/post-images/1601601050603.jpg" alt="" loading="lazy"><br>
5.安装完成后，勾选 Run IntelliJ IDEA，点击 Finish 运行软件:<br>
<img src="https://1725735819.github.io/post-images/1601601106253.jpg" alt="" loading="lazy"><br>
6.等待 IDEA 2020.2.1 运行, 中间会先弹出一个注册框，我们勾选 Evaluate for free, 点击 Evaluate， 先试用30天:<br>
<img src="https://1725735819.github.io/post-images/1601601190943.jpg" alt="" loading="lazy"><br>
7.进入 IDEA 中， 我们先随便建个 Java 工程， 然后将网盘中最新的 IDEA 破解补丁 jetbrains-agent-latest.zip拖入 IDEA 界面中，如下图所示：<br>
<img src="https://1725735819.github.io/post-images/1601601241269.jpg" alt="" loading="lazy"></p>
<p>补丁下载连接<br>
链接：https://pan.baidu.com/s/1IBz3nzSBtC55p99NGRJX7w<br>
提取码：a0ur</p>
<p>8.拖入补丁后会弹框，点击 restart 重启 IDEA：<br>
<img src="https://1725735819.github.io/post-images/1601601328003.jpg" alt="" loading="lazy"><br>
9.配置助手会提示您，需要使用哪种激活方式，这里我们选择默认的 Activation Code，通过安装参数来激活，点击为IDEA安装：<br>
PS: 安装参数内容同样放置在网盘中了，小伙伴自行拷贝出来即可。<br>
<img src="https://1725735819.github.io/post-images/1601601387540.jpg" alt="" loading="lazy"><br>
10.点击是，重启IDEA, 即激活成功啦~<br>
<img src="https://1725735819.github.io/post-images/1601601421990.jpg" alt="" loading="lazy"><br>
第四步: 验证 IDEA 是否激活成功<br>
1.进入 IDEA 界面后，点击 Help -&gt; Register 查看：<br>
<img src="https://1725735819.github.io/post-images/1601601511675.jpg" alt="" loading="lazy"><br>
2.可以看到，已经成功激活至 2089 年辣，撸到老，哈哈~<br>
<img src="https://1725735819.github.io/post-images/1601601564472.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot系列之小操作]]></title>
        <id>https://1725735819.github.io/post/spring-boot-xi-lie-zhi-xiao-cao-zuo/</id>
        <link href="https://1725735819.github.io/post/spring-boot-xi-lie-zhi-xiao-cao-zuo/">
        </link>
        <updated>2020-09-21T11:01:35.000Z</updated>
        <content type="html"><![CDATA[<p>格式化代码，清除不使用的包快捷键，maven自动导jar包</p>
<p>一、提示快捷键</p>
<p>idea默认快捷键是ctrl+space，通常和别的软件快捷键冲突，所以将快捷键修改为alt+/<br>
<img src="https://1725735819.github.io/post-images/1600686209755.png" alt="" loading="lazy"></p>
<p>二、格式化快捷键ctrl+alt+l，通常和qq、tim快捷键冲突，请修改qq或者tim快捷键。</p>
<p>三、自动清除导入的不使用的包，ctrl+alt+o</p>
<p>四、maven自动依赖jar包<br>
<img src="https://1725735819.github.io/post-images/1600686224570.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot系列之快速入门]]></title>
        <id>https://1725735819.github.io/post/springboot-xi-lie-zhi-kuai-su-ru-men/</id>
        <link href="https://1725735819.github.io/post/springboot-xi-lie-zhi-kuai-su-ru-men/">
        </link>
        <updated>2020-09-16T11:10:58.000Z</updated>
        <content type="html"><![CDATA[<p>简介<br>
Spring Boot已成为当今最流行的微服务开发框架，本文是如何使用Spring Boot快速开始Web微服务开发的指南，我们将使创建一个可运行的包含内嵌Web容器（默认使用的是Tomcat）的可运行Jar包。<br>
传统的Spring应用程序需要配置大量的XML文件才能运行，而使用Spring Boot只需极少的配置，就可以快速获得一个正常运行的Spring应用程序，而这些配置使用的都是注解的形式，不需要再配置XML。</p>
<p>SpringBoot主要优点：<br>
1、快速构建项目。<br>
2、对主流开发框架的无配置集成。<br>
3、项目可独立运行，无须外部依赖Servlet容器。<br>
4、提供一系列企业级项目的功能性特性（比如：安全、健康检测、外部化配置、数据库访问、restful搭建等）。<br>
5、提高了开发、部署效率。</p>
<p>maven构建项目</p>
<p>1、访问http://start.spring.io/<br>
2、选择构建工具Maven Project、Spring Boot版本1.3.6以及一些工程基本信息<br>
3、点击Generate Project下载项目压缩包<br>
4、解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done!</p>
<p>Spring Boot的基础结构共三个文件:<br>
src/main/java  程序开发以及主程序入口<br>
src/main/resources 配置文件<br>
src/test/java  测试程序</p>
<p>1、Application.java 建议放到跟目录下面,主要用于做一些框架配置<br>
2、domain目录主要用于实体（Entity）与数据访问层（Repository）<br>
3、service 层主要是业务类代码<br>
4、controller 负责页面访问控制</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义中 ResultMap中的 id 和result的区别]]></title>
        <id>https://1725735819.github.io/post/zi-ding-yi-zhong-resultmap-zhong-de-id-he-result-de-qu-bie/</id>
        <link href="https://1725735819.github.io/post/zi-ding-yi-zhong-resultmap-zhong-de-id-he-result-de-qu-bie/">
        </link>
        <updated>2020-09-14T12:07:56.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-&lt;resultMap">    &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;order_id&quot; property=&quot;orderId&quot; /&gt;
    &lt;result column=&quot;customer_register_id&quot; property=&quot;customerRegisterId&quot; /&gt;
    &lt;result column=&quot;entity_id&quot; property=&quot;entityId&quot; /&gt;
    &lt;result column=&quot;invoice_kind&quot; property=&quot;invoiceKind&quot; /&gt;
&lt;/resultMap&gt;
</code></pre>
<p>在自定义的resultMap中第一列通常是主键id，那么id 和result有什么区别呢？</p>
<p>id和result都是映射单列值到一个属性或字段的简单数据类型。</p>
<p>唯一不同是。id是作为唯一标识的，当和其他对象实例对比的时候，这个id很有用，尤其是应用到缓存和内嵌的结果映射。</p>
<p>property： 映射数据库列的字段或属性，如果JavaBean的属性与给定的名称匹配，就会使用匹配的名字,否则MyBatis将搜索给定名称的字段，两种情况下你都可以使用逗点的属性形式，比如，你可以映射到“”username：，也可以映射到“address.street.number”</p>
<p>column:数据库的列名或者列标签别名，与传递个resultSet.getString(columnName)的参数名称相同。</p>
<p>javaType:完整java类名或者别名，如果映射到一个JavaBean，那么MyBatis通常会自行监测到。然而如果映射到一个HashMap，那应该明确指定javaType来确保所需行为。</p>
<p>jdbcType;支持的jdbc类型，这个属性只在insert，update，delete的时候针对允许空的列有用，JDBC需要这项，但Mybatis不需要，如果直接编写JDBC代码，在允许为空值的情况下需要指定这个类型。</p>
<figure data-type="image" tabindex="1"><img src="https://1725735819.github.io/post-images/1600085396626.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SPring Boot系列之spring框架]]></title>
        <id>https://1725735819.github.io/post/spring-boot-xi-lie-zhi-spring-kuang-jia/</id>
        <link href="https://1725735819.github.io/post/spring-boot-xi-lie-zhi-spring-kuang-jia/">
        </link>
        <updated>2020-09-11T12:12:10.000Z</updated>
        <content type="html"><![CDATA[<p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p>
<p>◆目的：解决企业应用开发的复杂性<br>
◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能<br>
◆范围：任何Java应用<br>
Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<p>Spring的初衷：<br>
1、JAVA EE开发应该更加简单。<br>
2、使用接口而不是使用类，是更好的编程习惯。Spring将使用接口的复杂度几乎降低到了零。<br>
3、为JavaBean提供了一个更好的应用配置框架。<br>
4、更多地强调面向对象的设计，而不是现行的技术如JAVA EE。<br>
5、尽量减少不必要的异常捕捉。<br>
6、使应用程序更加容易测试。<br>
Spring的目标：<br>
1、可以令人方便愉快的使用Spring。<br>
2、应用程序代码并不依赖于Spring APIs。<br>
3、Spring不和现有的解决方案竞争，而是致力于将它们融合在一起。<br>
Spring的基本组成：<br>
1、最完善的轻量级核心框架。<br>
2、通用的事务管理抽象层。<br>
3、JDBC抽象层。<br>
4、集成了Toplink, Hibernate, JDO, and iBATIS SQL Maps。<br>
5、AOP功能。<br>
6、灵活的MVC Web应用框架。<br>
优点编辑<br>
◆JAVA EE应该更加容易使用。<br>
◆面向对象的设计比任何实现技术（比如JAVA EE）都重要。<br>
◆面向接口编程，而不是针对类编程。Spring将使用接口的复杂度降低到零。（面向接口编程有哪些复杂度？）<br>
◆代码应该易于测试。Spring框架会帮助你，使代码的测试更加简单。<br>
◆JavaBean提供了应用程序配置的最好方法。<br>
◆在Java中，已检查异常（Checked exception）被过度使用。框架不应该迫使你捕获不能恢复的异常。</p>
<p>模块</p>
<p>如果作为一个整体，这些模块为你提供了开发企业应用所需的一切。但你不必将应用完全基于Spring框架。你可以自由地挑选适合你的应用的模块而忽略其余的模块。<br>
就像你所看到的，所有的Spring模块都是在核心容器之上构建的。容器定义了Bean是如何创建、配置和管理的——更多的Spring细节。当你配置你的应用时，你会潜在地使用这些类。但是作为一名开发者，你最可能对影响容器所提供的服务的其它模块感兴趣。这些模块将会为你提供用于构建应用服务的框架，例如AOP和持久性。<br>
核心容器</p>
<p>这是Spring框架最基础的部分，它提供了依赖注入（DependencyInjection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。BeanFactory是工厂模式的一个实现，它使用IoC将应用配置和依赖说明从实际的应用代码中分离出来。<br>
应用上下文（Context）模块<br>
核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。<br>
另外，这个模块提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持。<br>
Spring的AOP模块<br>
Spring在它的AOP模块中提供了对面向切面编程的丰富支持。这个模块是在Spring应用中实现切面编程的基础。为了确保Spring与其它AOP框架的互用性，Spring的AOP支持基于AOP联盟定义的API。AOP联盟是一个开源项目，它的目标是通过定义一组共同的接口和组件来促进AOP的使用以及不同的AOP实现之间的互用性。通过访问他们的站点，你可以找到关于AOP联盟的更多内容。<br>
Spring的AOP模块也将元数据编程引入了Spring。使用Spring的元数据支持，你可以为你的源代码增加注释，指示Spring在何处以及如何应用切面函数。<br>
JDBC抽象和DAO模块<br>
使用JDBC经常导致大量的重复代码，取得连接、创建语句、处理结果集，然后关闭连接。Spring的JDBC和DAO模块抽取了这些重复代码，因此你可以保持你的数据库访问代码干净简洁，并且可以防止因关闭数据库资源失败而引起的问题。<br>
这个模块还在几种数据库服务器给出的错误消息之上建立了一个有意义的异常层。使你不用再试图破译神秘的私有的SQL错误消息！<br>
另外，这个模块还使用了Spring的AOP模块为Spring应用中的对象提供了事务管理服务。<br>
对象/关系映射集成模块<br>
对那些更喜欢使用对象/关系映射工具而不是直接使用JDBC的人，Spring提供了ORM模块。Spring并不试图实现它自己的ORM解决方案，而是为几种流行的ORM框架提供了集成方案，包括Hibernate、JDO和iBATIS SQL映射。Spring的事务管理支持这些ORM框架中的每一个也包括JDBC。<br>
Spring的Web模块<br>
Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。另外，这个模块还提供了一些面向服务支持。例如：实现文件上传的multipart请求，它也提供了Spring和其它Web框架的集成，比如Struts、WebWork。<br>
Spring的MVC框架<br>
Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts，但Spring的MVC框架使用IoC对控制逻辑和业务对象提供了完全的分离。<br>
它也允许你声明性地将请求参数绑定到你的业务对象中，此外，Spring的MVC框架还可以利用Spring的任何其它服务，例如国际化信息与验证。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot系列之自动配置 原理]]></title>
        <id>https://1725735819.github.io/post/spring-boot-xi-lie-zhi-zi-dong-pei-zhi-yuan-li/</id>
        <link href="https://1725735819.github.io/post/spring-boot-xi-lie-zhi-zi-dong-pei-zhi-yuan-li/">
        </link>
        <updated>2020-09-10T11:17:36.000Z</updated>
        <content type="html"><![CDATA[<p>不论在工作中，亦或是求职面试，Spring Boot已经成为我们必知必会的技能项。除了某些老旧的政府项目或金融项目持有观望态度外，如今的各行各业都在飞速的拥抱这个已经不是很新的Spring启动框架。</p>
<p>Spring Boot的配置文件<br>
初识Spring Boot时我们就知道，Spring Boot有一个全局配置文件：application.properties或application.yml。<br>
官方文档：</p>
<pre><code>https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties
</code></pre>
<p>1、自动配置原理：</p>
<p>1）SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration<br>
2）@EnableAutoConfiguration 作用：<br>
利用EnableAutoConfigurationImportSelector给容器中导入一些组件<br>
可以查看selectImports()方法的内容；<br>
List configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>
获取候选的配置</p>
<pre><code>SpringFactoriesLoader.loadFactoryNames()
扫描所有jar包类路径下 META‐INF/spring.factories
把扫描到的这些文件的内容包装成properties对象
从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中
</code></pre>
<p>3）、每一个自动配置类进行自动配置功能；<br>
4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；</p>
<pre><code>@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的
ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把
HttpEncodingProperties加入到ioc容器中
@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果
满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类
CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing =
true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的
//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
public class HttpEncodingAutoConfiguration {
    //他已经和SpringBoot的配置文件映射了
    private final HttpEncodingProperties properties;
//只有一个有参构造器的情况下，参数的值就会从容器中拿
public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
    this.properties = properties;
}
@Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取
@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？
public CharacterEncodingFilter characterEncodingFilter() {
    CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
    filter.setEncoding(this.properties.getCharset().name());
    filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
    filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
    return filter;
}
</code></pre>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；<br>
5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<p>2、细节</p>
<p>2.1@Conditional派生注解（Spring注解版原生的@Conditional作用）<br>
作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效</p>
<figure data-type="image" tabindex="1"><img src="https://1725735819.github.io/post-images/1599737061519.jpg" alt="" loading="lazy"></figure>
<p>自动配置类必须在一定的条件下才能生效；</p>
<p>我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置 类生效；</p>
<pre><code>=========================
AUTO‐CONFIGURATION REPORT
=========================
Positive matches:（自动配置类启用的）
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
DispatcherServletAutoConfiguration matched:
	‐ @ConditionalOnClass found required class
'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find
unwanted class (OnClassCondition)
‐ @ConditionalOnWebApplication (required) found StandardServletEnvironment
(OnWebApplicationCondition)
Negative matches:（没有启动，没有匹配成功的自动配置类）
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
ActiveMQAutoConfiguration:
Did not match:
‐ @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory',
'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)
AopAutoConfiguration:
Did not match:
‐ @ConditionalOnClass did not find required classes
'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot系列 之Spring Boot 注解大全]]></title>
        <id>https://1725735819.github.io/post/spring-boot-xi-lie-zhi-spring-boot-zhu-jie-da-quan/</id>
        <link href="https://1725735819.github.io/post/spring-boot-xi-lie-zhi-spring-boot-zhu-jie-da-quan/">
        </link>
        <updated>2020-09-09T11:32:25.000Z</updated>
        <content type="html"><![CDATA[<p>一、注解(annotations)列表<br>
@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。</p>
<p>@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p>
<p>@EnableAutoConfiguration 自动配置。</p>
<p>@ComponentScan 组件扫描，可自动发现和装配一些Bean。</p>
<p>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p>
<p>@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p>
<p>@Autowired自动导入。</p>
<p>@PathVariable获取参数。</p>
<p>@JsonBackReference解决嵌套外链问题。</p>
<p>@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。</p>
<p>二、注解(annotations)详解<br>
@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p>
<pre><code>package com.example.myproject; 
import org.springframework.boot.SpringApplication; 
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan 
public class Application { 
public static void main(String[] args) { 
SpringApplication.run(Application.class, args); 
} 
}
</code></pre>
<p>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：</p>
<pre><code>@RequestMapping(“/test”) 
@ResponseBody 
public String test(){ 
return”ok”; 
}
</code></pre>
<p>@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：</p>
<pre><code>@Controller 
@RequestMapping(“/demoInfo”) 
publicclass DemoController { 
@Autowired 
private DemoInfoService demoInfoService;

@RequestMapping(&quot;/hello&quot;)
public String hello(Map&lt;String,Object&gt; map){
   System.out.println(&quot;DemoController.hello()&quot;);
   map.put(&quot;hello&quot;,&quot;from TemplateController.helloHtml&quot;);
   //会使用hello.html或者hello.ftl模板进行渲染显示.
   return&quot;/hello&quot;;
}
}
</code></pre>
<p>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：</p>
<pre><code>package com.kfit.demo.web;

import org.springframework.web.bind.annotation.RequestMapping; 
import org.springframework.web.bind.annotation.RestController;


@RestController 
@RequestMapping(“/demoInfo2”) 
publicclass DemoController2 {

@RequestMapping(&quot;/test&quot;)
public String test(){
   return&quot;ok&quot;;
}
}
</code></pre>
<p>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。<br>
@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。<br>
@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。<br>
@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。<br>
@Import：用来导入其他配置类。<br>
@ImportResource：用来加载xml配置文件。<br>
@Autowired：自动导入依赖的bean<br>
@Service：一般用于修饰service层的组件<br>
@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。<br>
@Bean：用@Bean标注方法等价于XML中配置的bean。<br>
@Value：注入Spring boot application.properties配置的属性的值。示例代码：</p>
<pre><code>@Value(value = “#{message}”) 
private String message;
</code></pre>
<p>@Inject：等价于默认的@Autowired，只是没有required属性；<br>
@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。<br>
@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。<br>
@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。<br>
@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p>
<pre><code>@Autowired 
@Qualifier(value = “demoInfoService”) 
private DemoInfoService demoInfoService;
</code></pre>
<p>@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。<br>
三、JPA注解<br>
@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略<br>
@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。<br>
@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。<br>
@Column：如果字段名与列名相同，则可以省略。<br>
@Id：表示该属性为主键。<br>
@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。<br>
@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。<br>
@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式<br>
@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。<br>
@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。<br>
@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</p>
<p>四、springMVC相关注解</p>
<p>@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。<br>
用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：<br>
params:指定request中必须包含某些参数值是，才让该方法处理。<br>
headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>
value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>
method:指定请求的method类型， GET、POST、PUT、DELETE等<br>
consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>
produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br>
@RequestParam：用在方法的参数前面。<br>
@RequestParam<br>
String a =request.getParameter(“a”)。<br>
@PathVariable:路径变量。如</p>
<pre><code>RequestMapping(“user/get/mac/{macAddress}”) 
public String getByMacAddress(@PathVariable String macAddress){ 
//do something; 
} 
</code></pre>
<p>参数与大括号里的名字一样要相同。</p>
<p>五、全局异常处理</p>
<p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。<br>
@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[idea项目打开后，java文件有红色j，pom.xml变为普通的xml文件]]></title>
        <id>https://1725735819.github.io/post/idea-xiang-mu-da-kai-hou-java-wen-jian-you-hong-se-jpomxml-bian-wei-pu-tong-de-xml-wen-jian/</id>
        <link href="https://1725735819.github.io/post/idea-xiang-mu-da-kai-hou-java-wen-jian-you-hong-se-jpomxml-bian-wei-pu-tong-de-xml-wen-jian/">
        </link>
        <updated>2020-09-08T11:48:04.000Z</updated>
        <content type="html"><![CDATA[<p>1..java文件的结局方案</p>
<p>打开project Structure</p>
<p>选Modoles选sources将右边Add Content Root中内容全部移除</p>
<p>点击Add Content Root重新添加sources，j文件即可变成java文件</p>
<p>2.pom.xml文件的解决方案</p>
<p>idea没有识别出来mavn中的pom.xml文件,不能自动下载依赖包,</p>
<p>解决办：是选中pom.xml文件,右键&quot; add as maven project&quot;就可以了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://1725735819.github.io/post/hello-gridea/</id>
        <link href="https://1725735819.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>